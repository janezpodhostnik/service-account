[{"type":"String","value":"DependencyAudit"},{"type":"String","value":"import MigrationContractStaging from 0x56100d46aa9b0212\n\n// This contract is is used by the FVM calling the `checkDependencies` function from a function of the same name and singnature in the FlowServiceAccount contract,\n// at the end of every transaction.\n// The `dependenciesAddresses` and `dependenciesNames` will be all the dependencies needded to run that transaction.\n//\n// The `checkDependencies` function will check if any of the dependencies are not staged in the MigrationContractStaging contract.\n// If any of the dependencies are not staged, the function will emit an event with the unstaged dependencies, or panic if `panicOnUnstaged` is set to true.\naccess(all) contract DependencyAudit {\n\n    access(all) let AdministratorStoragePath: StoragePath\n\n    // The system addresses have contracts that will not be stages via the migration contract so we exclude them from the dependency chekcs\n    access(self) var excludedAddresses: {Address: Bool}\n\n    access(all) var panicOnUnstaged: Bool\n\n    access(all) event UnstagedDependencies(dependencies: [Dependency])\n\n    access(all) event PanicOnUnstagedDependenciesChanged(shouldPanic: Bool)\n\n    access(all) event BlockBoundariesChanged(start: UInt64?, end: UInt64?)\n\n    // checkDependencies is called from the FlowServiceAccount contract\n    access(account) fun checkDependencies(_ dependenciesAddresses: [Address], _ dependenciesNames: [String], _ authorizers: [Address]) {\n        var unstagedDependencies: [Dependency] = []\n\n        var numDependencies = dependenciesAddresses.length\n        var i = 0\n        while i < numDependencies {\n            let isExcluded = DependencyAudit.excludedAddresses[dependenciesAddresses[i]] ?? false\n            if isExcluded {\n                i = i + 1\n                continue\n            }\n\n            let staged = MigrationContractStaging.isStaged(address: dependenciesAddresses[i], name: dependenciesNames[i])\n            if !staged {\n                unstagedDependencies.append(Dependency(address: dependenciesAddresses[i], name: dependenciesNames[i]))\n            }\n\n            i = i + 1\n        }\n\n        if unstagedDependencies.length > 0 {\n            self.maybePanicOnUnstagedDependencies(unstagedDependencies)\n\n            emit UnstagedDependencies(dependencies: unstagedDependencies)\n        }\n    }\n\n    access(self) fun maybePanicOnUnstagedDependencies(_ unstagedDependencies: [Dependency]) {\n        // If `panicOnUnstaged` is set to false, the function will return without panicking\n        // Then check if we should panic randomly\n        if !DependencyAudit.panicOnUnstaged || !self.shouldPanicRandomly() {\n            return\n        }\n\n        var unstagedDependenciesString = \"\"\n        var numUnstagedDependencies = unstagedDependencies.length\n        var j = 0\n        while j < numUnstagedDependencies {\n            if j > 0 {\n                unstagedDependenciesString = unstagedDependenciesString.concat(\", \")\n            }\n            unstagedDependenciesString = unstagedDependenciesString.concat(unstagedDependencies[j].toString())\n\n            j = j + 1\n        }\n\n        // the transactions will fail with a message that looks like this: `error: panic: Found unstaged dependencies: A.2ceae959ed1a7e7a.MigrationContractStaging, A.2ceae959ed1a7e7a.DependencyAudit`\n        panic(\"This transaction is using dependencies not staged for Crescendo upgrade coming soon! Learn more: https://bit.ly/FLOWCRESCENDO. Dependencies not staged: \".concat(unstagedDependenciesString))\n    }\n\n    // shouldPanicRandomly is used to randomly panic on unstaged dependencies\n    // The probability of panicking is based on the current block height and the start and end block heights\n    // If the start block height is greater than or equal to the end block height, the function will return true\n    // The function will always return true if the current block is more than the end block height\n    // The function will always return false if the current block is less than the start block height\n    // The function will return true if a random number between the start and end block heights is less than the current block height\n    // This means the probability of panicking increases linearly as the current block height approaches the end block height\n    access(self) fun shouldPanicRandomly(): Bool {\n        // get start block height or true\n        // get end block height or true\n        // get current block height\n        // get random number between start and end\n        // if random number is less than current block return true\n        // else return false\n\n        let maybeBoundaries = self.getBoundaries()\n        if maybeBoundaries == nil {\n            // if settings are invalid use default behaviour: panic true\n            return true\n        }\n        let boundaries = maybeBoundaries!\n\n        let startBlock: UInt64 = boundaries.start\n        let endBlock: UInt64 = boundaries.end\n        let currentBlock: UInt64 = getCurrentBlock().height\n\n        if startBlock >= endBlock {\n            // this should never happen becuse we validate the boundaries when setting them\n            // if settings are invalid use default behaviour: panic true\n            return true\n        }\n\n        let dif = endBlock - startBlock\n        var rnd = revertibleRandom<UInt64>() % dif\n        rnd = rnd + startBlock\n\n        // fail if the random number is less than the current block\n        return rnd < currentBlock\n    }\n\n    access(all) struct Boundaries {\n        access(all) let start: UInt64\n        access(all) let end: UInt64\n\n        init(start: UInt64, end: UInt64) {\n            self.start = start\n            self.end = end\n        }\n    }\n\n    access(all) fun getBoundaries(): Boundaries? {\n        return self.account.storage.copy<Boundaries>(from: /storage/flowDependencyAuditBoundaries)\n    }\n\n    access(all) fun getCurrentFailureProbability(): UFix64 {\n        if !DependencyAudit.panicOnUnstaged {\n            return 0.0 as UFix64\n        }\n\n        let maybeBoundaries = self.getBoundaries()\n        if maybeBoundaries == nil {\n            return 1.0 as UFix64\n        }\n\n        let boundaries = maybeBoundaries!\n\n        let startBlock: UInt64 = boundaries.start\n        let endBlock: UInt64 = boundaries.end\n        let currentBlock: UInt64 = getCurrentBlock().height\n\n        if startBlock >= endBlock {\n            return 1.0 as UFix64\n        }\n        if currentBlock >= endBlock {\n            return 1.0 as UFix64\n        }\n        if currentBlock < startBlock {\n            return 0.0 as UFix64\n        }\n\n        let dif = endBlock - startBlock\n        let currentDif = currentBlock - startBlock\n\n        return UFix64(currentDif) / UFix64(dif)\n    }\n\n    access(self) fun setBoundaries(boundaries: Boundaries) {\n        self.account.storage.load<Boundaries>(from: /storage/flowDependencyAuditBoundaries)\n        self.account.storage.save(boundaries, to: /storage/flowDependencyAuditBoundaries)\n    }\n\n    access(self) fun unsetBoundaries() {\n        self.account.storage.load<Boundaries>(from: /storage/flowDependencyAuditBoundaries)\n    }\n\n    // The Administrator resorce can be used to add or remove addresses from the excludedAddresses dictionary\n    //\n    access(all) resource Administrator {\n        // addExcludedAddresses add the addresses to the excludedAddresses dictionary\n        access(all) fun addExcludedAddresses(addresses: [Address]) {\n            for address in addresses {\n                DependencyAudit.excludedAddresses[address] = true\n            }\n        }\n\n        // removeExcludedAddresses remove the addresses from the excludedAddresses dictionary\n        access(all) fun removeExcludedAddresses(addresses: [Address]) {\n            for address in addresses {\n                DependencyAudit.excludedAddresses.remove(key: address)\n            }\n        }\n\n        // setPanicOnUnstagedDependencies sets the `panicOnUnstaged` variable to the value of `shouldPanic`\n        access(all) fun setPanicOnUnstagedDependencies(shouldPanic: Bool) {\n            DependencyAudit.panicOnUnstaged = shouldPanic\n            emit PanicOnUnstagedDependenciesChanged(shouldPanic: shouldPanic)\n        }\n\n        // setStartEndBlock sets the start and end block heights for the `shouldPanicRandomly` function\n        access(all) fun setStartEndBlock(start: UInt64, end: UInt64) {\n            pre {\n                start < end: \"Start block height must be less than end block height\"\n            }\n\n            let boundaries = Boundaries(start: start, end: end)\n            DependencyAudit.setBoundaries(boundaries: boundaries)\n            emit BlockBoundariesChanged(start: start, end: end)\n        }\n\n        // unsetStartEndBlock unsets the start and end block heights for the `shouldPanicRandomly` function\n        access(all) fun unsetStartEndBlock() {\n            DependencyAudit.unsetBoundaries()\n            emit BlockBoundariesChanged(start: nil, end: nil)\n        }\n\n        // testCheckDependencies is used for testing purposes\n        // It will call the `checkDependencies` function with the provided dependencies\n        // `checkDependencies` is otherwise not callable from the outside\n        access(all) fun testCheckDependencies(_ dependenciesAddresses: [Address], _ dependenciesNames: [String], _ authorizers: [Address]) {\n            return DependencyAudit.checkDependencies(dependenciesAddresses, dependenciesNames, authorizers)\n        }\n    }\n\n    access(all) struct Dependency {\n        access(all) let address: Address\n        access(all) let name: String\n\n        init(address: Address, name: String) {\n            self.address = address\n            self.name = name\n        }\n\n        access(all) fun toString(): String {\n            var addressString = self.address.toString()\n            // remove 0x prefix\n            addressString = addressString.slice(from: 2, upTo: addressString.length)\n            return \"A.\".concat(addressString).concat(\".\").concat(self.name)\n        }\n    }\n\n    // The admin resource is saved to the storage so that the admin can be accessed by the service account\n    // The `excludedAddresses` will be the addresses with the system contracts.\n    init(excludedAddresses: [Address]) {\n        self.excludedAddresses = {}\n        self.panicOnUnstaged = false\n\n        self.AdministratorStoragePath = /storage/flowDependencyAuditAdmin\n\n        for address in excludedAddresses {\n            self.excludedAddresses[address] = true\n        }\n\n        let admin <- create Administrator()\n        self.account.storage.save(<-admin, to: self.AdministratorStoragePath)\n    }\n}\n"}]